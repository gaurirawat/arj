Why DAO?
- controller is to define endpoints of the application
- service is to handle ugly business logic and separate it from our endpoints
- DAO is for accessing data models and do CRUD hence it will decouple business logic and access layer so they can grow independently.

Optional:
- Is to establish that there can be no value to return and method will make explicit check everytime we use it so to avoid nullPointer exception.
- https://www.baeldung.com/java-optional-return
- https://dzone.com/articles/java-8-optional-how-use-it#:~:text=Optional%20is%20a%20new%20container,ssn)%20%7B%20...%20%7D

getOne() vs findById():
- https://stackoverflow.com/questions/24482117/when-use-getone-and-findone-methods-spring-data-jpa

Passing of data
https://lankydan.dev/2017/03/11/passing-data-transfer-objects-with-get-in-spring-boot
https://www.xspdf.com/resolution/50438739.html

FetchType Lazy and Eager:
-to-many : Default is Lazy
-to-one : Default is Eager
https://thorben-janssen.com/entity-mappings-introduction-jpa-fetchtypes/

Annotations:
@JsonRootName('value'): to use custom value as key in serialization and deserialization. We need to explicitly enable WRAP_ROOT_VALUE for root-name to be used.
If not specified then class name will be used.
@JsonIgnoreProperties:
https://www.concretepage.com/jackson-api/jackson-jsonignore-jsonignoreproperties-and-jsonignoretype#JsonIgnoreProperties

Circular Reference:
https://www.baeldung.com/jackson-bidirectional-relationships-and-infinite-recursion

unidirectional mapping best practices:
https://www.baeldung.com/hibernate-one-to-many

SessiosnStorage LocalStorage Cookie:
https://stackoverflow.com/questions/19867599/what-is-the-difference-between-localstorage-sessionstorage-session-and-cookies
https://www.digitalocean.com/community/tutorials/js-introduction-localstorage-sessionstorage

Cookie and HTTP headers:
HTTP headers are used to pass additional information with HTTP response or HTTP requests.
A cookie is an HTTP request header i.e. used in the requests sent by the user to the server.
It contains the cookies previously sent by the server using set-cookies.
https://dzone.com/articles/how-to-use-cookies-in-spring-boot
https://attacomsian.com/blog/cookies-spring-boot

how to make authentication and authorization stateless:
https://golb.hplar.ch/2019/05/stateless.html
https://medium.com/@erangadulshan.14/replace-inmemory-token-store-with-a-persistent-one-in-spring-boot-oauth2-c00a4c35f90f

CSRF and XSS:
Hey Sagar – so, once you enable CSRF protection, you’ll have to adapt your clients to send the new CSRF token as well. So, you’ll have to modify your client (your form, or whatever you’re using to do the upload) – to make sure it does send that new token.
And, if you’re accessing the API programmatically, you’ll of course have to take care of sending that token yourself (some libraries do have support for that).
Hope that helps. Cheers,
Eugen.
ResponseEntity:
https://www.baeldung.com/spring-boot-json
https://www.baeldung.com/spring-response-entity

blueberry cheesecake:

filter and streams:

Remaining:
Mr->status is int and not string : Done
createProjectService(); Done
findByCurrentLevelOfHierarchyAndStatusAndProject_Manager(): test
findProcessedMR(); : Done
findItemsByService(); : Done

Corrections:
the findItemByService service is consuming incorrect dao function. : Done

mr-> service-> item-> itemMRMapping-> mr
itemMRMappings-> materialRequest-> service-> items-> itemMRMappings


